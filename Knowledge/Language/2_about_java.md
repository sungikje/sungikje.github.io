---
title: About Java
layout: home
parent: Language
nav_order: 2
---


## Table of contents
{ .no_toc .text-delta }
1. TOC
{:toc}

<br><br>



 - procedural programming
 
## Assembler
>
- 어셈블 언어 - 인간이 이해하기 쉽도록 기계어와 거의 일대일로 대응하는 기호로 표현된 언어
    -   이진법과 우리가 평소에 쓰는 언어들을 규칙을 갖고 일대일로 매칭시켜 놓은 것
-   고급 언어로 기술하는 것보다 어려움
    -   고급 언어 - 사람을 기준으로 이해하기 쉬운 언어를 고급 언어라 한다
        -   ex) C/C++, JAVA 등
            -   C++의 경우 memory를 건들기 때문에 쉽지만은 않다
-   어셈블러는 번역하는 프로그램
-   assemble - 변역하는 것

## 바이트 코드
>
-   소스코드를 플랫폼에 독립적인 명령어로 구성된 이진 표기로 변환한 파일
-   JVM은 바이트 코드를 특정 플랫폼(OS)에 맞는 기계어 파일로 변환하는 역할
    -   변환하는 과정에서 한 단계를 더 거쳐 속도 조금 느리지만 고려할 정도는 아니다
-   file내에서 .class로 되어 있는 파일

## 컴퓨터에 전달되는 과정
>
-   소스파일   --(컴파일)-->   바이트 코드   --(인터프리터=JVM)-->   OS
    -   컴파일 - 고급 언어로 작성된 언어를 기계어가 이해할 수 있게 번역하는 것
        -   컴파일러 - 컴파일 하는 프로그램
    -   인터프리터 - 고급 언어로 작성된 코드를 한 단계씩 해석하여 실행시키는 것
        -   ex) JVM(java virtual machine), 통역관 역할

## 프롬프트
>
-   컴퓨터가 입력을 받아들일 준비가 되었다는 것을 사용자에게 나타내어 주기 위해 컴퓨터 단말기 화면에 나타나는 신호
-   cmd
    -   명령프롬프트 - command prompt 
        -   window 명령어 처리기
        -   명령어
```
div  //현재 목록 보기
cd \  //directory 위치 잡는거 초기화 = 처음으로
cd (폴더)  //change directory
dir  //directory
copy con  //문자 복사
```
- 컴파일 : javac 파일명
- 실행 : java 파일명

## 개발환경
>
- python에서 실행환경을 위해 pip, install 했던 것들이 java에서는 pom.xml에 넣고 저장하는 과정
  - install, pom.xml을 이용해 각 언어들 lib 추가 가능

## 프로그램 파일
>
-   파일 - 컴퓨터 내에서 의미를 가지는 논리적인 단위
-   텍스트 파일 - 문자 그대로 저장
-   바이너리(binary) 파일 - 이진 형태로 저장 (프로그램 입장에서 편함)
-   확장자 - program을 결정, file을 구분해줌 - 오른쪽에서 시작해 처음으로 나오는 .(dot)까지
    -   java file 확장자 - pdf 1-3 참고
        -   jar(java archive) - 클래스 내에 리소스 파일, 메타 데이터를 포함해 패키징
        -   war(web archive) - 웹과 관련된 모든 내용들 패키징
        -   ear(enterprise archive) - jar + war 패키징
-   폴더(directory) - 다수의 파일을 포함

# Java
## class
>
-   java program의 (단위=unit)이고 대소문자를 구분
-   하나의 클래스는 하나의 소스 파일
-   제품(객체)을 위한 틀, 설계도
    -   객체 - 메모리에 생성되어 만들어진 형태 
    -   객체 = 속성 + 행동
-   변수와 메소드로 구성
-   인스턴스화 - Class를 이용해 객체를 생성하는 것
-   인스턴스 – 인스턴스화 해서 만들어진 객체
-   public을 사용하는 Class 존재 안할 수 있지만 존재한다면 소스 파일과 이름 무조건 일치, 하나만 존재 가능
-   생성자 정의 할 때 변수 = 참조형 변수
-   .(dot) 이용해 객체에 접근

### 변수
>
-   필드 - 속성 - 소속변수(member variables)
- 객체의 참조 변수를 포함한 local 변수의 경우 stack에 저장
-   자료형
    -   기본형 
        -   상수, 변수, 레터럴 등 단어에 집착하지 말고 의미 신경
            -   상수 - 불린형, 정수, 실수, 문자형, 문자열 
                -   기본형  
                    -   정수 - int type
                        -   초기값 없는 경우 기본값 0으로
                    -   실수 - double type
                        -   초기값 없는 경우 0.0으로 초기화
                    -   문자형
                        -   초기값 없는 경우 기본값 '\\0', '\\u0000'
                            -   하지만 char type 경우 기본값 대신 공백으로 초기화
                    -   기본형이 아닌 변수 타입 선언 시 마지막에 변수 타입의 첫 글자 적어줌
        -   숫자 표기법
            -   앞에 진수 정의 쓰고 2진수로 0000\_0000 형태로 변수 이용 가능
                -   진수(0b)뒤에 첫번 째 자리 = 부호 bit
                -   short의 경우 연산은 int로 해야 됨, 아니면 short를 연산 앞에 정의해줘야된다
                    -   ex) (shrot)(s1 + s2) 
            -   10진수
                -   e : 승 표현
            -   2진수
                -   ex) int 0b10 - 0b표현
            -   16진수
                -   ex) int 0x10 : 0x 표현
                -   p : 16진수의 승 표현, p+1 등
            -   8진수
                -   ex) int 010 : 0표현
    -   참조형 
        -   지칭하는 것의 메모리 주소 가리킴 
        -   링크와 유사
        -   초기 값 없는 경우 기본값 null
        - class 기반 타입 지칭
    -   bit 표현 자료형 연산
        -   덧셈 - 정상적으로 수행
        -   뺄셈 - 정상적으로 수행 X
            -   2의 보수 이용해 개선
                -   보수 : 논리회로 로직사용
                    -   연산 기호 (~)
                -   1의 보수(0,1 반대로 다 바꾸고) 처리 이후 2의 보수(마지막 자리에 +1)
        -   오버플로우, 언더플로우
            -   오버 - max 값에 bit 1을 더한다고 더 커지지 않음
            -   언더 - min 값에 bit 1을 빼준다고 더 작아지지 않음
-   문자형
    -   공백 or null 표시 필요, 공백이랑 null은 다른 것
-   data type별로 연산하는 방법들이 다르다는 것을 깔고 가야됨
    -   예를 들어 숫자형은 사칙 연산, 문자형은 길이 호출, 특정 구간 제거 등
-   변수의 data type을 정의해주는 것이 변수를 사용함에 따라 data type을 판단하는 수고를 덜어준다
-   CASTING에서 형변환을 정의해주는 경우 명시적 형변환이라 부름
    -   ```
        ex) int x = (int) 1.54;
        ```
-   import를 통해 class를 바로 사용할 수 있게끔 하는데 이는 프로젝트에 라이브러리를 폴더 형식으로 추가한 경우도 클래스 위치를 마찬가지로 import해 사용 가능
-   primitive
    -   원시적인, 기본 data type
        -   boolean, int, double, short, long, float, char
    -   데이터 생성 시 같은 값의 데이터에 대해 동일한 주소 참조
-   non primitive
    -   primitive가 아닌 경우
        -   String, Array, Date, File 등
    -   문자열 정의
        -   new 사용해 정의
            -   데이터 생성 시 객체 생성이라 볼 수 있다
                -   서로 다른 주소 참조
                -   비교 연산자 사용 X, equals 사용
        -   new 없이 정의  
            -   primitive와 같음
                -   하지만 원시 데이터가 아닌 경우 equals 사용 추천
                
### 멤버, 지역 변수
>
#### 멤버 변수
- class 내부에서 사용, 초기화 없이 사용 가능
  - static 유무로 class 변수, instance 변수 나뉨
- 속성 값 가지고 있기 때문에 영역 X
- stack에 저장
#### 지역 변수 
- 메소드 내부에서 사용
- 메소드 내부에서만 사용 가능하고 메소드 벗어나면 메모리에서 사라짐
- 초기화 없이 선언만으로 사용 가능하지만 컴파일 시 오류 발생, 반드시 초기화 필요
- 언더바 ( \_ ) 주로 사용   
- heap에 저장

### 클래스, 인스턴스 변수
#### 클래스 변수
>
- Static사용한 경우 클래스 변수,클래스 메소드
- 클래스에 소속된 저장공간이 하나만 존재하는 변수 
  - 클래스 메모리에 올라갈 때 자동 생성
  - 객체를 만들 때 객체 입장에서 값 수정이 필요 없는 경우 = 멤버 변수 중에 모든 인스턴스들이 공통으로 사용하는 것에 static 붙인다
- 객체 없이 사용 가능 
  - ex) 클래스이름.메서드이름(매개변수)
- Static이 붙은 경우 붙지 않은 인스턴스 변수, 메소드 사용 불가, 하지만 반대(=인스턴스 변수나 메서드에서는 static이 붙은 멤버들 사용)는 가능
- 프로그램의 실행 속도 향상을 위해 사용하지 않는 변수들 static 붙일 것을 고려 
  - 안 붙인 메소드는 실행 시 호출되어야 하므로
    - 이는 찾아가는 과정이 추가된다는 의미
#### 인스턴스 변수
- 인스턴스 변수를 필요로 한다 -> 인스턴스를 생성해야만 호출 할 수 있음 = 객체 생성 후에만 호출가능
    
### abstract 
>
-   추상클래스
    -   미완성 설계도라 생각 
        -   직접 객체화 불가 
            -   생성자 사용해 객체를 생성할 수 없다는 것 의미
    -   다른 클래스에 의해 상속되어야 하는 것이 포인트
        -   하위클래스가 있어야 의미가 있고 그렇기에 final 키워드 사용 X
    -   생성자가 있으며,  멤버 변수와 메서드도 가질 수 있다
    -   상속계층도에서 맨 위에 위치한 모든 하위클래스들의 공통점이라 볼 수 있다
    -   적어도 하나 이상의 추상 메소드를 가진 경우 반드시 추상 class
-   추상메소드
    -   미완성 메소드  
    -   구조
        -   abstract (리턴타입) (메서드이름)( );
    -   선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둠 
        -   몸체 없이 바로 세미콜론 이용해 삽입
    -   메서드의 내용이 상속받은 클래스에 따라 달라질 수 있으므로 상위클래스에서 선언부만 작성하고 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성했는지 알려주고 실제 내용은 상속받은 클래스에서 구현하도록 비워두는 것
    -   상속받은 하위클래스에서 오버라이딩해서 사용 
        -   만약 상위 클래스에 추상 메서드 중 하나라도 구현하지 않는다면 상속 받은 하위 클래스 역시 추상클래스로 정의 해줘야 된다
        
### Interface
>
-   추상클래스와 유사
    -   하지만 인터페이스는 추상화 정도 더 커 몸통을 갖춘 일반 메소드 또는 멤버 변수를 구성원으로 가질 수 없음
    -   추상 클래스는 일반적인 메소드 + 추상 메소드 가능하지만 인터페이스는 only 추상 메소드
-   해야 할 작업의 구체적 구현 없이 기능만 선언한 클래스
-   하위 클래스가 수행해야 되는 메소드와 필요한 상수만 미리 추상적으로 정의
-   조건
    -   모든 멤버 변수는 public static final이어야 하며 생략 가능
    -   모든 메서드는 public abstract이어야 되며 생략 가능 
    -   static메서드와 디폴드 메서드는 예외
-   일반적인 상속과 똑같이 참조 변수로 참조 가능 \+ 다중 상속 지원
-   인터페이스를 상속받은 하위 클래스는 모든 추상 메소드를 구현 필요
    -   전부 정의 안할 시 마찬가지로 하위클래스 추상클래스로 정의 필요
-   다형성과 마찬가지로 인터페이스를 A라는 클래스가 구현했을 때 인터페이스를 일반적인 class type처럼 사용 가능
    -   메서드의 매개변수의 type으로도 사용 가능하다
        -   이 경우는 인터페이스를 구현한 클래스의 객체를 매개변수로 제공해야 한다는 것
    -   return type으로도 지정 가능
        -   이는 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미  
-   Public or default만 사용 가능
-   조금 더 유연한 class라 생각하면 될 것 같다
    -   프로그램의 원하는 형태, 구체적인 구동 방법은 우리가 직접 정의해 사용할 수 있기에
        -   버그는 있을지언정 호환되지 않는 문제는 없을 것 
-   값(=변수) 선언 가능
    -   class에 자동으로 implements된다

### object class
>
- 모든 클래스의 최고 조상 
- 모든 클래스에서 바로 사용 가능(=extends 사용 안해도 확장됨, 확장 키워드 필요 없음)

### String class
>
- 문자열을 위한 class
- Final로 정의되어 있어 변경 불가
  - + 이용해 문자열 결합하는 경우 인스턴스 내에 문자열 바뀌는 것이 아니라 새로운 문자열이 담긴 string인스턴스가 생성되는 것 
    - 메모리 위해 가능한 적게 연산하는 것이 효율적, StringBuffer class로 개선 가능
- 문자열 리터럴,생성자 두 가지 방법으로 문자열 생성 가능
    - 리터럴의 경우 문자열이 동일하면 주소 값도 동일
    - 리터럴 생성 시 해당 클래스에 리터럴->리터럴 같은 경우 모두 똑 같은 메모리 참조
    - 생성자의 경우 문자열 같아도 주소값 다름, 객체가 다르기 때문
- String type의 경우 null보다는 빈 문자열로 초기화하는 것이 보통

### StringBuffer class
- 저장된 문자열 변경이 가능하므로 하나의 인스턴스로 다양한 문자열 다루는 것이 가능메모리에 주는 영향 줄이기 위해 변경이 많은 경우 buffer class 이용
- Char [] 형식으로 데이터를 저장하는데 이는 buffer(=공간)라 칭하며 문자열의 수정을 용이하게 해주는 역할
- 선언할 때 buffer의 크기를 문자열의 길이와 관련하여 넉넉하게 정의하는 것이 좋으며 정의 안할 시 16개의 문자를 저장할 수 있는 크기의 buffer생성
- 배열의 길이는 변경될 수 없으므로 새로운 길이의 배열을 생성한 후에 이전 배열의 값을 복사해야 한다, copy 이용

### Date, Calendar
>
- 날짜와 시간
- Calendar 클래스 이후 대부분의 메서드는 calendar에서 가져오고 date는 저장의 용도로만 사용
#### Calendar
- 추상클래스이므로 직접 객체 생성 불가,메서드 통해서 완전히 구현된 클래스의 인스턴스 얻어야한다
  - getInstatnce()이용
    - calendar class를 구현한 클래스의 인스턴스를 반환한다 	
      - static인 이유 : 메서드 내의 코드에서 인스턴스 변수를 사용하거나 인스턴스 메서드를 호출하지 않기 때문
      - static이 아니라면 객체를 생성하고 호출해야 되는데 calendar가 추상클래스이므로 불가
      
### Generic class
>
- 원시타입 + 타입변수(=타입 매개변수, = 지네릭타입)로 이루어져있음
  - 타입변수 자리에 특정 타입을 지정해 호출한다면 특정 타입(=매개변수화된 타입 = 대입된 타입)
	컴파일 후에 원시타입으로 바뀌는 것에 대해 ????????????????
  - 지네릭 타입이 아닌 클래스의 타입 간에 다형성을 적용하는 것은 가능, 이 때도 지네릭 타입은 일치해야됨
    - 지네릭 클래스를 이용해 특정 타입의 자손 객체만 저장하고 싶은 경우 462p     
    
### 멤버 변수 초기화
>
-   초기화 블럭
    -   클래스 초기화 블록  :  클래스 변수 초기화에 사용
    -   인스턴스 초기화 블록  :  인스턴스 변수 초기화에 사용
    -   클래스 변수(cv)가 인스턴스 변수(iv)보다 먼저 초기화  
        -   인스턴스 초기화 블록은 인스턴스가 필요하기 때문
-   명시적 초기화 - 변수를 선언과 동시에 초기화
    -   절대적이진 않지만 해도 나쁠게 없음, 물론 불필요한 경우도 충분히 존재
-   참고
    -   변수
    -   멤버 변수
        -   클래스 변수
        -   인스턴스 변수
    -   지역 변수

### 접근 지정자
>
- Public :어디서든 접근 가능
- Protected :같은 패키지 내에서와 다른 패키지에서는 상속한 class만 접근 가능
- (Default) :같은 package내에서만 사용 가능접근 지정자 생략한 경우
- Private : class내에서만 접근 가능
- (Static =정적):필드,메소드 소속을 클래스로 제한하는 키워드
  - 멤버 변수 중에 모든 인스턴스들이 공통으로 사용하는 것에 static 붙인다
  - static 내부에서는 this, super 사용 못함


## 메소드(함수)
>
-   parameter, return 값으로 이루어질 수 있으며 둘 다 필 수는 아니다
    -   return type 함수 이름 앞에 작성
        -   ex) return 값 없는 경우 - void
-   public static void main(String[] args){} 
    - 특별한 함수
    - 프로그램의 starting point라 생각하면 된다
    - main없이 실행하는 방법
      1. 단위 test인 jUnit framework 사용(@Test 선언된 메소드 실행)
      2. server와 browser로 실행
-   메소드의 특정 내용을 실행하기 위해 영역이 필요
- 참고
  -   close 함수
      -   하나의 프로그램이 하나의 파일을 잡고 있다면 다른 프로그램들을 읽기는 가능하지만 쓰지는 못함
      -   독점 작업을 해주고 반드시 놔줘야 한다
      





## 생성자
>
-   단순하게 인스턴스를 시작할 때 인스턴스의 변수 및 메소드 초기화를 위해 사용하는 특별한 메소드
-   구조는 메소드와 유사하지만 return 값이 없다
    -   반환이 없지만 그렇다고 void 사용 안함
-   이름은 반드시 클래스 이름, 인자의 유무는 때에 따라 유동적
-   주로 접근지정자로 public사용
    -   다른 접근지정자들도 사용 가능
-   생성자는 단순하게 인스턴스 변수들의 초기화에 사용
    -   객체를 생성하는 것은 new 키워드
-   임의로 생성자 구현 안한 경우 기본생성자 따로 정의 안해도 자동으로 정의됨
    -   만약 임의로 생성자 구현했다면 기본 생성자 자동으로 정의 X
-   constructor overloading - 생성자 오버로딩
    -   같은 이름으로 여러 생성자 구현 가능
    -   parameter들의 type만 인식하지 변수의 이름을 보지 않기 때문 
        -   method 이름은 같지만 parameter만 다른 경우들 
-   기본 생성자인 경우 인스턴스 생성한 이 후 인스턴스 변수들 따로 초기화 필요
-   매개변수가 있는 생성자는 인스턴스가 생성과 동시에 생성자 값으로 초기화 됨
-   생성자
    -   class 호출하는 method
        -   생성과 동시에 초기화하고 싶은 경우
            -   class type과 동일한 이름의 method가 존재한다면 해당 method에 매개변수 이용해 초기화
            
## 객체
>
- https://velog.io/@sung-ik-je/%EA%B0%9D%EC%B2%B4-%EC%B6%94%EC%83%81%ED%99%94
          

## 절차, 객체지향
### 절차치향 - procedural programming
>
-   객체지향과 대비되는 말로 프로그램을 순서에 맞게 단계적으로 실행함
-   데이터의 속성보다는 명령어의 순서와 흐름에 포커싱
-   기능들이 복잡해지면서 추가 개발이나 유지보수가 어려운 한계 존재
-   method를 이용해 부품을 만들고 프로그램 만듬


### 객체지향 - object oriented programming(OOP)
>
- https://velog.io/@sung-ik-je/%EA%B0%9D%EC%B2%B4-%EC%B6%94%EC%83%81%ED%99%94
-   절차 지향의 method만을 이용하기에는 한계를 느낌
-   class(method + variable)를 이용해 부픔을 만들고 프로그램 만듬
-   클래스 class
    -   서로 연관된 같은 주제를 가지고 있는 변수와 메서드를 그룹화한 껍데기
    -   멤버
        -   ex) 클래스 멤버 변수 - 클래스 소속 변수 뜻함  

### this
>
-   객체 자신을 의미하는 키워드 
    -   변수들의 이름 같은 경우 멤버변수와 지역변수 구분하기 위해 사용
    -   생성자를 사용하는 객체가 아닌 본인이 속해 있는 필드 가리킴
-   This 있는 경우 생성자가 속해있는 class의 변수(=멤버 변수)를 가리킴 
    -   ex) this.color = color;
-   This 없으면 만들어질 객체의 변수(=지역 변수)로 취급
    -   만들어질 객체의 초기값 
    -   생성자의 매개변수 
    -   생성자 내에서 한번만 사용 가능
-   자식 클래스를 가리킴  
    -   상위 클래스에서 하위 클래스 지칭 할 때 생성자의 입장에서는 this 사용하면 만들어질 인스턴스의 변수로 초기화 
        -   this.a = 2;
            -   생성자를 사용하는 객체(=자식 클래스)의 a라는 변수를 2로 초기화 
            -   생성자로 만들어질 객체를 초기화하는데 사용하는 것과 같은 말

### super
>
-   상위 객체를 의미하는 키워드 
    -   하위클래스에서 상위 클래스의 변수 지칭할 때 사용
-   변수의 이름이 같을 때 구분을 위해 super사용
    -   super.변수 
        -   상위class의 변수 가리킴
-   상속된 하위 클래스에 상위 클래스와 동일한 이름의 변수 없을 경우에는 하위 클래스에서 this 이용해 상위클래스의 변수 접근 가능하지만 대부분 super이용


### this, super
>
-   this와 super은 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점만 제외하면 근본적으로 같다 
    -   this, super이용해 반대로 접근 가능한 것 
-   super와 this를 사용할 때 super, this 키워드를 사용하는 클래스 내에 변수와 생성자의 매개변수가 다르다는 사실 유의 
    -   클래스 내에 변수 vs 생성자 매개변수

### this()
>
같은 클래스의 다른 생성자를 호출할 때 사용

### super()
>
-   상위 클래스의 기본 생성자를 호출하는 문장
-   기본 생성자가 없는 경우 자바컴파일러가 기본적으로 제공
-   조상의 생성자를 호출하는데 사용(생성자는 상속 안되기 때문)

## 상속 - Inheritance
>
-   eclipse에서 클래스, 메서드 우클릭 Quick Type Hierarchy을 통해 해당 클래스, 메서드들의 상속 관계와 포함하고 있는 메서드들을 알 수 있다
    -   하위클래스에서 메서드를 사용할 때 상속해준 모든 상위클래스들의 메서드 존재 유무를 파악
        -   미리 정의되어 있는 메서드를 사용, 수정(override) 가능
        -   메서드는 바로 이전에 상속해주는 상위클래스에 존재할수도, 존재하지 않을 수도 있으며 override된 메서드가 존재하는 경우도 존재
            -   만약 상위 클래스에 정의되어 있는 경우 상위 클래스 중 가장 근접한 곳에 정의되어 있는 클래스의 메서드를 따라가고, 정의 안되어 있는 경우 새로운 함수 정의해줘야 한다
-   Overloading
    -   상속과 직접적인 관련 X
    -   클래스 내에서 같은 이름의 메서드를 중복해서 생성하는 것 
        -   특정 이름을 지닌 메소드가 있다고 할지라도 우리는 같은 이름을 가진 메소드를 또 만들 수 있다
        -   다만 파라미터 형식이 달라야 한다
-   Override
    -   부모 클래스가 갖고 있는 기능을 재정의
-   상위 클래스의 생성자가 있다면 하위 클래스가 상속 받을 때 생성자를 정의해줘야 한다     

## 다형성 - Polymorphism
>
-   클래스가 데이터 타입에 따라 다양한 형태로 보여질 수 있는 성질(하나의 class가 여러가지 모습을 띌 수 있는)
    -   생성자 정의시 interface type 종류에 따라 선언한 변수 영향 받음
        -   호환성 문제 존재 
    -   클래스의 기능이 너무 많아져서, 선택적으로 사용자에게 제공하고 싶어질 때
        -   기능이 많으면 자유도는 높지만 복잡성 증가
        -   필요 없는 부분은 고려 안하고 필요한 부분들만 사용 가능

## package
>
-   소문자 이용
-   .(dot)이용해 하위 폴더 지정
-   directory라 생각

## 키워드
>
-   \=예약어
-   \= 자바 자체적으로 미리 정의해 놓은 단어
-   식별자로 사용 불가

## 식별자
>
-   사용자가 정의한 단어들
-   대소문자 구분
-   밑줄, 달러 기호, 한글 가능
-   첫 문자 숫자 불가, 공백 불가

## 주석
>
-   한줄 주석 - //
-   블록 주석 - /\* \*/
-   문서화 주석 - /\*\*       문장 앞에 \* 사용                \*/
    -   ex) 작성자 표시할 때 사용

## 인덴테이션
>
-   들여쓰기
-   가독성을 위한 것이지 컴퓨터 입장에선 의미 X

## 표기법
>
-   참고, 하지만 실무에서 지켜야 되는게 예의
-   헝가리언 - 변수 선언 시 변수 이름 앞에 data type적어줌
    -   ex) int iMaxSpeed;  or   String strUserName;
-   파스칼 - 클래스 선언 시 각 문자들의 첫 문자 대문자
    -   Public class가 있는 경우에 source file name도 첫 문자 대문자가 맞는 것 같음
-   카멜 - 변수, 메소드 선언 시에 처음에 나오는 단어의 첫 글자만 소문자, 두번째 글자부터는 파스칼표기법 따름
-   언더바 (=스네이크) - java에서는 상수를 표현, 나머지 언어들은 필기 참고
-   케밥 - html에서 class 정의 시 언더바 대신 (–)이용

## 형식 문자열
>
-   %d - 숫자 10진수로 출력
-   %o - 숫자 8진수로 출력
-   %x - 숫자 16진수로 출력(소문자)
-   %X - 숫자 16진수로 출력(대문자)
-   %f - 소수점 형식으로 출력
-   %c - 문자로 출력
-   %s - 문자열로 출력

## 관계연산자
>
-   \==의 경우 주소 값을 비교
-   \===의 경우 형식까지 고려
-   return 값은 Boolean 값

## 캐스팅
### 업캐스팅
>
-   상위로의 자료형변환 
    -   하위 객체는 상위 클래스형 변수에 대입이 가능
-   class 구조 :  사람 > 교직원 > 직원인 경우
    -   김사랑은 원래 교직원 class인데 사람 class의 김사람으로 정의
        -   \= (교직원 김사랑; 을 사람 김사람으로 재정의) 
        -   김사람은 사람의 변수이므로 사람의 멤버만 접근 가능
            -   접근 할 수 있는 변수 줄어듬
    -   사람에서 교직원, 교직원에서 직원으로 상속
        -   직원이 가장 하위 클래스이며 사용 하는 변수 직원이 가장 많음
-   클래스에 따라 접근할 수 있는 변수가 다르며 상위클래스로 변할 경우 마찬가지로 접근할 수 있는 변수들의 권한이 바뀐다

### 다운캐스팅
>
-   상속 관계가 성립해야 된다
-   상위 클래스 형을 하위 클래스 형으로 변환 
    -   이 때 반드시 명시적인 형변환 연산자 필요
    
## 리펙토링 - Refactoring
>
-   결과는 똑같은데 내용을 효율적으로 만드는 것
-   eclipse에서는 refactor 기능 지원

## Resource
>
-   Java 외부에 존재하는 것들
    -   종류
        -   DB
        -   Network
        -   File
-   굉장히 불안전하고 여러가지 상황 초래
    -   작업이 끝나면 붙잡고 있던 resouce를 놔줘야됨
        -   close() 함수 이용
            -   보통 finally 이용해 사용



