---
title: About Docker
parent: CS
layout: home
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }
1. TOC
{:toc}

_인프런 초보를 위한 도커 안내서 강의 기반_

<br><br><br><br><br>

# Docker란?
소프트웨어를 격리 시켜 서버 프로그램 간의 의존성을 떨어뜨리며 서버 관리의 효율성을 높여주는 소프트웨어
  + 가상머신처럼 OS 위에서 Hypervisor, Guest OS를 이용한 오버헤드가 발생하지 않으며 단순히 소프트웨어를 격리 시켜주는 역할(Host OS 위 계층에서 작동) 
  + 가상머신의 상위호환이라 볼 수 있다
    + 가상머신처럼 독립적으로 실행 가능하지만 더 빠르고 쉬우며 효율적(가상머신의 경우 pc에서 진행하는 것보다 무겁고 느림)

#### 가상머신
가상머신은 물리적 컴퓨터와 동일한 기능을 제공하는 소프트웨어라고 생각하면 된다. 소프트웨어 내에서 물리적으로 분리되어 컴퓨터의 기능을 제공하는 소프트웨어

#### 도커가 가상머신보다 빠른 이유는?
가상 머신(VM)의 경우 하이퍼바이저를 통해 호스트 운영체제 위에 게스트 운영체제를 실행, 각 VM은 독립적인 운영체제(OS)를 갖추고 있어 애플리케이션을 실행하기 위해 OS와 커널을 모두 포함한 무거운 환경을 생성
  + 이로 인해 부팅 시간도 길고 리소스 사용이 더 많다

도커의 경우 호스트 OS의 커널을 공유하며 애플리케이션과 그에 필요한 라이브러리 및 종속성만 포함하는 가벼운 컨테이너를 생성
  + 추가적인 운영체제 실행이 필요 없으며 이는 자원을 더 효율적으로 사용하고 컨테이너의 부팅 속도를 크게 줄인다
    
<br>

각 개의 프로그램들을 `컨테이너`라는 형태로 격리시킨다
  + `컨테이너`는 소프트웨어 실행에 필요한 모든 환경들을 패키징하고 격리시키는 것을 의미
  + 이 컨테이너들은 어디에서든 실행이 가능하다

## 왜 사용하는지?
_우선 앞 서 언급했던 것처럼 서버 내 프로그램들을 효율적으로 사용하기 위한 목적으로, 서버의 상태를 정상적으로 관리하기 위한 노력을 덜고자 도커가 탄생_

### 서버 관리의 어려움
#### 서버 환경 설정과 환경 변화
Oracle, WordPress, Git-Lab 등과 같은 프로그램들을 서버에 설치해 실행하는 것이 쉬운 일이 아니며 거기에 더 해 서버에서 사용하는 프로그램들은 계속해서 변화한다

#### 서버 내 개발 환경의 변화
뿐만 아니라 소프트웨어를 개발하는데 있어 사용되는 언어, 프레임워크 등도 마찬가지

#### 프로그램 간의 의존성
전통적인 방식의 경우 서버 내 모든 자원과 설정 파일 등을 프로그램들이 함께 공유하며 서로 의존하고 있는 관계라 보면 된다
  + 특정 설정의 변화, 자원의 변화가 관련 있는 모든 프로그램에 영향을 준다
  
### 서버 관리 방식의 변화
앞서 언급했던 것 처럼 `전통적인 서버관리 방식`은 서버 내 모든 환경들이 서로 의존 관계가 존재하며 공통된 자원을 모두 공유하는 방식
  + 이는 사소한 설정 변화로 의존하고 있는 다양한 서버 환경에 영향을 줄 수 있다
<br>

초기에는 서버를 관리할 때 `문서`로 기록하며 서버 환경을 관리했고 이후에 `서버 상태 관리 도구`(일반적인 문서가 아닌 코드로 이루어짐)를 이용했다

이 후 하나의 서버에 여러 버전을 관리 할 목적으로 `가상머신`을 이용
  + 느리고 세팅할 때 마다 가상화 시킨 정보를 알아야 하며 그로 인해 초기 세팅하는 일련의 과정을 반복해야 되는 부담 존재
  + 사용하고자 하는 소프트웨어들을 가상머신으로 만들고 가상머신을 관리하는 서버를 하나 만들어 해당 서버에서 가상머신들을 투입
  + 서로 영향 없이 돌아가는 이상적이라 생각할 수 있지만 서버 자원을 비효율적으로 사용
    + 용량이 크며 내용 공유에 대한 방법이 어려움

<br>

기술력이 아주 아주 뛰어난 회사의 경우 가상으로 프로세스, 파일, 디렉토리, CPU, MEORY, I/O 들을 분리해 `자원 격리`를 시키면서 운영하지만 대부분 해당 기술을 원활하게 사용하지 못한다
  + 이를 보다 쉽게 적용할 수 있게끔 해주는 것이 도커

### 장점
우선 Docker라는 기술은 오픈 소스이기에 특정 회사나 서비스에 종속적이지 않다 
<br>
보통 서비스(언어, 프레임워크 등) 별로 배포 방식이 다른데 도커의 경우는 컨테이너라는 표준이 존재하기 때문에 모든 서비스들의 배포 과정이 동일해진다 
  + 프로그램을 실행하는데 있어 필요한 여러가지 환경들을 도커가 모두 제공해줌(필요한 java, python, mysql 등의 환경들을)

#### 결론적으로 도커는 서버를 보다 쉽게 관리할 수 있게끔 하는 소프트웨어

#### 그래도 하나의 PC에서 도커를 이용해 여러 컨테이너를 띄웠을 때 각 컨테이너들은 PC의 자원을 공유하는 것 아닌가?
Docker는 리눅스의 Namespace와 Cgroups(컨트롤 그룹)이라는 기능을 이용해 각 컨테이너가 서로 독립적으로 실행시키면서도 시스템 자원을 잘 관리하고 격리할 수 있도록 한다
  + Namespace는 각 컨테이너가 자신의 프로세스, 네트워크, 사용자, 파일 시스템 등을 독립적으로 가질 수 있게 해주며 이는 컨테이너 간 시스템 리소스를 볼 수 없으며 마치 독립된 시스템처럼 동작하게끔 한다
  + Cgroups는 CPU, 메모리, 디스크 I/O, 네트워크 대역폭 등의 자원을 각 컨테이너마다 할당하고 제한하는 기능을 제공한다
    + 이를 통해 서로 다른 컨테이너나 호스트 시스템에 영향을 미치는 것을 방지한다 

<br><br><br><br><br>

## 이미지?
도커에서 이미지란 컨테이너를 실행하는 압축 파일을 의미한다
  + `Dockerfile`을 이용해 이미지를 만들며 가상머신과 비교해 초기 세팅 시 크게 어려움 없다
<br>

프로세스 실행을 목적으로 하는 파일들의 집합으로, 실행되는데 필요한 리눅스 프로그램들의 압축이라 생각하면 된다 
  + 도커는 이미지 단위로 프로세스 실행 환경을 구성한다
<br>

이미지에 이미지를 쌓으면서 커스텀하게 새로운 이미지 형태를 구축할 수 있다

이미지 생성 방법
  + `docker commit` : 명령어를 한줄씩 서버 내에서 타이핑, 주로 실시간으로 컨테이너에서 수동으로 변경한 내용을 이미지로 저장할 때 사용
    + 변경 사항이 기록된 스크립트가 없어서 일관성 유지하기 어렵다, 이미지 생성 과정이 명확하지 않고 자동화하기 어렵다
  + `docker build` : 명령어를 특정 파일에 기록 및 실행
    + Dockerfile을 기반으로 이미지를 빌드, 자동화된 방법으로 반복적이고 일관된 이미지를 생성할 때 사용
      + 개인적으로 이미지 관련 커스텀 로그 명령어를 손쉽게 볼 수 있는 면에서 `build` 명령어가 더 유용하다고 생각한다

### 이미지 생성
도커는 기본적으로 이미지를 생성하는데 있어 캐시를 사용

때문에 명령어가 적혀 있는 `Dockerfile` 내 변경 사항이 없는 경우 빌드 시간이 굉장히 짧아진다
  + 명령어의 변경 사항이 확인 되는 최초의 지점부터 캐시가 아닌 명령어를 직접 실행시킴
  + A, B, C 코드 뭉치에서 B가 변경된 경우 C의 코드가 변경되어 있든 아니든 B, C 명령어를 직접 실행
    + 이 때 B, C의 순서 변경이 큰 의미가 없다면 A, C, B 형태로 명령어를 수정하는 것이 효율적
    
### 이미지 저장소, Docker Hub
도커 이미지를 저장하는 공간으로 이미지를 저장소에 만들고 필요에 따라 여러 서버에서 가져다 사용할 수 있다 


서버 내 설정 파일 경로가 겹칠 수도 있으며 버전마다 여러 경로를 하나의 서버에서 관리하기가 어렵지만 도커를 사용하면 쉽게 가능하다

### 이미지 만들고 컨테이너 실행시키는 구체적인 프로세스
_여기서 예시는 바이너리 실행 파일 생성하는 프로젝트의 경우_
#### Ex 1
_다른 사람이 이미지를 받아서 바로 실행 가능한 일관적인 형태 제공 가능_

Dockerfile 작성
  + build 환경 설정, 필요한 패키지 설치
  + 소스 코드 복사 및 빌드
  + 빌드 명령어 ex) CMake
  + 실행 파일 실행하는 명령어 입력
  
Docker Image build (docker build ..~)
Docker Container 실행<br>
#### Ex 2
_코드를 쉽게 수정, 빌드, 테스트 진행 가능하다_
Dockerfile 작성
  + build 환경 설정, 필요한 패키지 설치
  + 작업 디렉토리(소스 코드 위치) 설정
  
Image Build, 컨테이너 실행(이 때 프로젝트 소스 코드 컨테이너에 마운트) 
코드 수정, 빌드 및 실행

<br><br><br><br><br>

## VS 쿠버네티스
우선 도커에 대해 얘기하자면 도커는 하나의 프로그램을 관리하는 방식 

그에 반해 쿠버네티스는 여러 대의 서버와 여러 개의 서비스를 관리하기 쉽게 하는 것

결국 쿠버네티스 안에 도커가 여러 개 존재하며 이를 관리하기 쉽게 해주는 것 
>
1. 스케줄링, 여유 있는 서버에 컨테이너 배포
2. 서버 죽으면 다른 서버에 컨테이너 띄어줌
3. 클러스터링, 여러 개의 서버를 하나의 서버처럼 사용, 모든 서버를 한 곳에서 컨트롤
4. 2번의 경우에서 컨테이너가 띄워지는 위치를 정확히 파악하는 기술도 존재(컨테이너 띄워주는 서버를 실시간으로 관측 가능하다는 것


<br><br><br><br><br>

## 참고
### 도커 운영 원리
도커는 서버-클라이언트 구조로 도커를 서버에 다운 받고 명령어를 치면 명령어를 친 컴퓨터(현재 내 서버 컴퓨터)가 클라이언트이며 도커 서버로 명령어를 전송, 도커 서버는 명령어에 따른 결과를 응답
### 도커를 이용한 서버에서의 데이터
기본저긍로 컨테이너 내에서 사용하는 데이터들은 컨테이너를 삭제하는 경우 함께 사라진다

`하지만` 컨테이너를 가동할 때 데이터를 서버 내 특정 폴더에 별도로 저장하는 설정을 거치면 컨테이너를 삭제하고 재가동하는 경우에도 폴더 내의 저장되어 있는 데이터를 계속해서 사용할 수 있다

### 명령어 
`docker ps` : 실행 중인 컨테이너 확인 

`docker ps -a` : 컨테이너 실행 기록 확인 

`docker stop {id}` : 도커 종료

`docker logs` : 실행 중인 컨테이너 로그 확인

`docker pull` : 이미지 다운로드
  + `docker run` 이용 시 이미지 다운로드 및 실행

`docker rmi` : 이미지 삭제

`docker network create` : 도커 컨테이너끼리 이름으로 통신할 수 있는 네트워크 생성
  + `docker network connect` : 기존에 생성된 컨테이너에 네트워크 추가

